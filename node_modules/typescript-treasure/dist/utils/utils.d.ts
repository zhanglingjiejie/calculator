import { Str, StrToTuple, VarUnion } from "..";
export type FlexEqual<X, Y> = X extends Y ? true : false;
export type If_FlexEqual<X, Y> = X extends Y ? true : false;
export type Equal<X, Y> = (<T>() => T extends X ? 1 : 2) extends (<T>() => T extends Y ? 1 : 2) ? true : false;
export type UnEqual<X, Y> = true extends Equal<X, Y> ? false : true;
export type If_Equal<X, Y> = Equal<X, Y>;
export type If_UnEqual<X, Y> = UnEqual<X, Y>;
export type If_Any<T> = 0 extends (1 & T) ? true : false;
export type If_UnAny<T> = true extends If_Any<T> ? false : true;
export type If_Never<T> = [T] extends [never] ? true : false;
export type If_UnNever<T> = Not<If_Never<T>>;
export type Check<T extends true> = T;
export type If_IncludeVar<T> = T extends string ? (T extends `${infer F}${infer R}` ? (F extends VarUnion ? true : If_IncludeVar<R>) : (false)) : (false);
export type Not<T extends boolean> = T extends true ? false : true;
export type Or<T extends boolean> = If_Never<T> extends true ? (false) : ((T extends true ? true : never) extends never ? false : true);
export type And<T extends boolean> = If_Never<T> extends true ? false : T;
export type If_Every<T> = (T extends true ? (true) : (false)) extends true ? true : false;
export type If_Some<T extends boolean> = Or<T>;
export type If_Union<T, U = T> = If_Never<T> extends true ? (false) : (T extends U ? ([
    U
] extends [T] ? false : true) : (never));
export type If_Num<T> = If_Never<T> extends true ? (false) : (T extends number ? true : false);
export type If_UnionInclude<T, S> = If_Never<S> extends true ? (false) : (S extends T ? true : false);
export type GetKeyOf<T, K = keyof T> = K extends K ? K : never;
export type GetValueOf<T, K extends keyof T = keyof T> = K extends K ? T[K] : never;
export type If_Arr<T> = If_Never<T> extends true ? (false) : (T extends any[] ? (true) : (false));
export type If_Tuple<T> = If_Never<T> extends true ? (false) : (T extends readonly any[] ? (number extends T["length"] ? false : true) : (false));
export type Len<T extends any[] | string, TargetType extends string | number = number> = T extends string ? (Type<StrToTuple<T>["length"], TargetType>) : (Type<T["length"], TargetType>);
export type Switch<Cases extends any[], Default = never> = Cases extends [infer Curr extends any[], ...infer R] ? (Curr[0] extends true ? (Curr[1]) : (Switch<R, Default>)) : (Default);
export type TypeOf<T> = T extends string ? (string) : (T extends number ? (number) : (T extends bigint ? (bigint) : (never)));
export type Type<T extends string | number | bigint | boolean, TargetType extends string | number | bigint | boolean> = Str<T> extends `${infer CT extends TargetType}` ? CT : T;
export type If_Extends<Sub, Parent> = If_Never<Sub> extends true ? (If_Never<Parent> extends true ? (true) : (false)) : (Sub extends Parent ? true : false);
