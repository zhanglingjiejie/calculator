import { If_FlexEqual, If_StrLenEq, If_StrLenGt, Not, Or, Str, Type, TypeOf } from '../';
import { Div, Mul, MulSum, Plus, Sub, _DelLeftZero } from './calc';
export * from "./calc";
export type ParseInt<T extends string | number | bigint, Target extends number | bigint = number> = `${T}` extends `${infer I extends Target}` ? I : never;
export type If_PositiveNum<T extends number | string | bigint> = Str<T> extends `-${infer I extends number}` ? false : true;
export type If_NegativeNum<T extends number | string | bigint> = Not<If_PositiveNum<T>>;
export type Abs<T extends number | string | bigint, TargetType extends number | string | bigint = TypeOf<T>> = `${T}` extends `-${infer I extends TargetType}` ? I : T;
export type Negative<T extends number | string | bigint, TargetType extends number | string | bigint = TypeOf<T>> = Str<T> extends "0" ? (Type<"0", TargetType>) : (Type<Str<T> extends `-${number}` ? T : `-${T}`, TargetType>);
type IncreaserMap = {
    "0": "1";
    "1": "2";
    "2": "3";
    "3": "4";
    "4": "5";
    "5": "6";
    "6": "7";
    "7": "8";
    "8": "9";
    "9": "0";
};
export type StrNumLiteral = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9";
export type IncreaserStrNum<T extends string, result extends string = "", mark extends boolean = true> = T extends `${infer before}${StrNumLiteral}` ? (T extends `${before}${infer last extends StrNumLiteral}` ? (IncreaserStrNum<before, `${mark extends true ? IncreaserMap[last] : last}${result}`, mark extends true ? last extends "9" ? true : false : false>) : (never)) : (mark extends true ? (result extends "" ? "" : `1${result}`) : (result));
export type Increaser<T extends string | number | bigint, TargetType extends string | number | bigint = TypeOf<T>> = IncreaserStrNum<Str<T>> extends `${infer S extends TargetType}` ? S : never;
type DecreaserMap = {
    "0": "9";
    "1": "0";
    "2": "1";
    "3": "2";
    "4": "3";
    "5": "4";
    "6": "5";
    "7": "6";
    "8": "7";
    "9": "8";
};
export type DecreaserStrNum<nstr extends string, result extends string = "", mark extends boolean = true> = nstr extends `${infer before}${StrNumLiteral}` ? (nstr extends `${before}${infer last extends StrNumLiteral}` ? (DecreaserStrNum<before, `${mark extends true ? DecreaserMap[last] : last}${result}`, last extends "0" ? mark extends true ? true : false : false>) : (never)) : (_DelLeftZero<result>);
export type Decreaser<T extends string | number | bigint, TargetType extends string | number | bigint = TypeOf<T>> = DecreaserStrNum<Str<T>> extends `${infer S extends TargetType}` ? S : never;
type GtMap = {
    "0": {
        "0": false;
        "1": false;
        "2": false;
        "3": false;
        "4": false;
        "5": false;
        "6": false;
        "7": false;
        "8": false;
        "9": false;
    };
    "1": {
        "0": true;
        "1": false;
        "2": false;
        "3": false;
        "4": false;
        "5": false;
        "6": false;
        "7": false;
        "8": false;
        "9": false;
    };
    "2": {
        "0": true;
        "1": true;
        "2": false;
        "3": false;
        "4": false;
        "5": false;
        "6": false;
        "7": false;
        "8": false;
        "9": false;
    };
    "3": {
        "0": true;
        "1": true;
        "2": true;
        "3": false;
        "4": false;
        "5": false;
        "6": false;
        "7": false;
        "8": false;
        "9": false;
    };
    "4": {
        "0": true;
        "1": true;
        "2": true;
        "3": true;
        "4": false;
        "5": false;
        "6": false;
        "7": false;
        "8": false;
        "9": false;
    };
    "5": {
        "0": true;
        "1": true;
        "2": true;
        "3": true;
        "4": true;
        "5": false;
        "6": false;
        "7": false;
        "8": false;
        "9": false;
    };
    "6": {
        "0": true;
        "1": true;
        "2": true;
        "3": true;
        "4": true;
        "5": true;
        "6": false;
        "7": false;
        "8": false;
        "9": false;
    };
    "7": {
        "0": true;
        "1": true;
        "2": true;
        "3": true;
        "4": true;
        "5": true;
        "6": true;
        "7": false;
        "8": false;
        "9": false;
    };
    "8": {
        "0": true;
        "1": true;
        "2": true;
        "3": true;
        "4": true;
        "5": true;
        "6": true;
        "7": true;
        "8": false;
        "9": false;
    };
    "9": {
        "0": true;
        "1": true;
        "2": true;
        "3": true;
        "4": true;
        "5": true;
        "6": true;
        "7": true;
        "8": true;
        "9": false;
    };
};
type If_PositiveStrGt<num1 extends string, num2 extends string> = If_StrLenGt<num1, num2> extends true ? (true) : (If_StrLenEq<num1, num2> extends true ? (_If_PositiveStrGt<num1, num2>) : (false));
type _If_PositiveStrGt<num1 extends string, num2 extends string> = num1 extends `${infer curr1 extends StrNumLiteral}${infer after1}` ? (num2 extends `${infer curr2 extends StrNumLiteral}${infer after2}` ? (curr1 extends curr2 ? (_If_PositiveStrGt<after1, after2>) : (GtMap[curr1][curr2])) : (never)) : (false);
export type If_PositiveStrGte<num1 extends string, num2 extends string> = Or<If_PositiveStrGt<num1, num2> | If_FlexEqual<num1, num2>>;
export type If_PositiveStrLt<num1 extends string, num2 extends string> = If_PositiveStrGt<num2, num1>;
export type If_PositiveStrLte<num1 extends string, num2 extends string> = Or<If_PositiveStrLt<num1, num2> | If_FlexEqual<num1, num2>>;
export type If_StrNumGt<num1 extends string, num2 extends string> = If_NegativeNum<num1> extends true ? (If_NegativeNum<num2> extends true ? (If_PositiveStrLt<Abs<num1>, Abs<num2>>) : (false)) : (If_NegativeNum<num2> extends true ? (true) : (If_PositiveStrGt<num1, num2>));
export type If_StrNumGte<num1 extends string, num2 extends string> = Or<If_StrNumGt<num1, num2> | If_FlexEqual<num1, num2>>;
export type If_StrNumLt<num1 extends string, num2 extends string> = If_StrNumGt<num2, num1>;
export type If_StrNumLte<num1 extends string, num2 extends string> = Or<If_StrNumLt<num1, num2> | If_FlexEqual<num1, num2>>;
export type If_Gt<num1 extends number | string | bigint, num2 extends number | string | bigint> = If_StrNumGt<Str<num1>, Str<num2>>;
export type If_Gte<num1 extends number | string | bigint, num2 extends number | string | bigint> = If_StrNumGte<Str<num1>, Str<num2>>;
export type If_Lt<num1 extends number | string | bigint, num2 extends number | string | bigint> = If_StrNumLt<Str<num1>, Str<num2>>;
export type If_Lte<num1 extends number | string | bigint, num2 extends number | string | bigint> = If_StrNumLte<Str<num1>, Str<num2>>;
type NumPosInfo<N extends string, count extends number = 2, result extends any[] = []> = count extends 0 ? ([
    N extends "" ? 0 : ParseInt<N>,
    ...result
]) : (N extends `${infer before}${StrNumLiteral}` ? (N extends `${before}${infer bit}` ? (NumPosInfo<before, Decreaser<count>, [ParseInt<bit>, ...result]>) : (NumPosInfo<before, Decreaser<count>, [0, ...result]>)) : (NumPosInfo<N, Decreaser<count>, [0, ...result]>));
type _GetRangeCount<start extends number, end extends number, step extends number = 1> = Div<Sub<end, start>, step, string> extends infer int_num extends string ? (Increaser<int_num>) : (never);
type _Range_Hundred<start extends number, end extends number, step extends number> = If_Gt<start, end> extends true ? never : _Range100<start, end, step>;
type _Range_Ten<start extends number, end extends number, step extends number> = If_Gt<start, end> extends true ? never : _Range10<start, end, step>;
type _Range_Key_Num<start extends number, step extends number, hundred extends number, ten extends number> = Plus<start, MulSum<[hundred, 100, step]>> extends infer n1 extends number ? (Plus<n1, MulSum<[step, ten, 10]>> extends infer n2 extends number ? ([
    n1,
    n2
]) : (never)) : (never);
export type Range<start extends number, end extends number, step extends number = 1> = If_Gt<start, end> extends true ? (never) : (NumPosInfo<_GetRangeCount<start, end, step>> extends [infer hundred extends number, infer ten extends number, infer unit extends number] ? (_Range_Key_Num<start, step, hundred, ten> extends [infer n1 extends number, infer n2 extends number] ? ((hundred extends 0 ? never : _Range_Hundred<start, Sub<n1, step>, step>) | (ten extends 0 ? never : _Range_Ten<n1, Sub<n2, step>, step>) | (unit extends 0 ? never : _Range1<n2, Plus<n2, Mul<step, Decreaser<unit>>>, step>)) : (never)) : (never));
type _Range1<start extends number, end extends number, step extends number = 1, result extends any = never> = start extends end ? (result | end) : (_Range1<Plus<start, step>, end, step, result | start>);
type _Range10<start extends number, end extends number, step extends number = 1, result extends any = never, end_next = Plus<end, step>> = start extends end_next ? (result) : (_Range10<Plus<start, Mul<step, 10>>, end, step, result | start | Plus<start, Mul<step, 1>> | Plus<start, Mul<step, 2>> | Plus<start, Mul<step, 3>> | Plus<start, Mul<step, 4>> | Plus<start, Mul<step, 5>> | Plus<start, Mul<step, 6>> | Plus<start, Mul<step, 7>> | Plus<start, Mul<step, 8>> | Plus<start, Mul<step, 9>>, end_next>);
type _Range100<start extends number, end extends number, step extends number = 1, result extends any = start, end_next = Plus<end, step>> = start extends end_next ? (result) : (_Range100<Plus<start, Mul<step, 100>>, end, step, result | start | Plus<start, Mul<step, 1>> | Plus<start, Mul<step, 2>> | Plus<start, Mul<step, 3>> | Plus<start, Mul<step, 4>> | Plus<start, Mul<step, 5>> | Plus<start, Mul<step, 6>> | Plus<start, Mul<step, 7>> | Plus<start, Mul<step, 8>> | Plus<start, Mul<step, 9>> | Plus<start, Mul<step, 10>> | Plus<start, Mul<step, 11>> | Plus<start, Mul<step, 12>> | Plus<start, Mul<step, 13>> | Plus<start, Mul<step, 14>> | Plus<start, Mul<step, 15>> | Plus<start, Mul<step, 16>> | Plus<start, Mul<step, 17>> | Plus<start, Mul<step, 18>> | Plus<start, Mul<step, 19>> | Plus<start, Mul<step, 20>> | Plus<start, Mul<step, 21>> | Plus<start, Mul<step, 22>> | Plus<start, Mul<step, 23>> | Plus<start, Mul<step, 24>> | Plus<start, Mul<step, 25>> | Plus<start, Mul<step, 26>> | Plus<start, Mul<step, 27>> | Plus<start, Mul<step, 28>> | Plus<start, Mul<step, 29>> | Plus<start, Mul<step, 30>> | Plus<start, Mul<step, 31>> | Plus<start, Mul<step, 32>> | Plus<start, Mul<step, 33>> | Plus<start, Mul<step, 34>> | Plus<start, Mul<step, 35>> | Plus<start, Mul<step, 36>> | Plus<start, Mul<step, 37>> | Plus<start, Mul<step, 38>> | Plus<start, Mul<step, 39>> | Plus<start, Mul<step, 40>> | Plus<start, Mul<step, 41>> | Plus<start, Mul<step, 42>> | Plus<start, Mul<step, 43>> | Plus<start, Mul<step, 44>> | Plus<start, Mul<step, 45>> | Plus<start, Mul<step, 46>> | Plus<start, Mul<step, 47>> | Plus<start, Mul<step, 48>> | Plus<start, Mul<step, 49>> | Plus<start, Mul<step, 50>> | Plus<start, Mul<step, 51>> | Plus<start, Mul<step, 52>> | Plus<start, Mul<step, 53>> | Plus<start, Mul<step, 54>> | Plus<start, Mul<step, 55>> | Plus<start, Mul<step, 56>> | Plus<start, Mul<step, 57>> | Plus<start, Mul<step, 58>> | Plus<start, Mul<step, 59>> | Plus<start, Mul<step, 60>> | Plus<start, Mul<step, 61>> | Plus<start, Mul<step, 62>> | Plus<start, Mul<step, 63>> | Plus<start, Mul<step, 64>> | Plus<start, Mul<step, 65>> | Plus<start, Mul<step, 66>> | Plus<start, Mul<step, 67>> | Plus<start, Mul<step, 68>> | Plus<start, Mul<step, 69>> | Plus<start, Mul<step, 70>> | Plus<start, Mul<step, 71>> | Plus<start, Mul<step, 72>> | Plus<start, Mul<step, 73>> | Plus<start, Mul<step, 74>> | Plus<start, Mul<step, 75>> | Plus<start, Mul<step, 76>> | Plus<start, Mul<step, 77>> | Plus<start, Mul<step, 78>> | Plus<start, Mul<step, 79>> | Plus<start, Mul<step, 80>> | Plus<start, Mul<step, 81>> | Plus<start, Mul<step, 82>> | Plus<start, Mul<step, 83>> | Plus<start, Mul<step, 84>> | Plus<start, Mul<step, 85>> | Plus<start, Mul<step, 86>> | Plus<start, Mul<step, 87>> | Plus<start, Mul<step, 88>> | Plus<start, Mul<step, 89>> | Plus<start, Mul<step, 90>> | Plus<start, Mul<step, 91>> | Plus<start, Mul<step, 92>> | Plus<start, Mul<step, 93>> | Plus<start, Mul<step, 94>> | Plus<start, Mul<step, 95>> | Plus<start, Mul<step, 96>> | Plus<start, Mul<step, 97>> | Plus<start, Mul<step, 98>> | Plus<start, Mul<step, 99>>>);
