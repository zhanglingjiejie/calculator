import { If_EmptyStr, Str } from '../string/string';
import { If_Never, Len, Type, TypeOf } from '../utils/utils';
import { MulMap, PlusMantissaMap, PlusOverBoolMap, SubMantissaMap, SubShrinkBoolMap } from './calc-table';
import { DecreaserStrNum, If_Gt, If_PositiveStrGte, If_PositiveStrLt, IncreaserStrNum } from './number';
type K = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9";
type If_BothFalse<A, B> = A extends false ? (B extends false ? (true) : (false)) : (false);
type PopLast<num extends string, def = "0"> = num extends `${infer before}${K}` ? (`${num}` extends `${before}${infer last}` ? last : def) : (def);
type PopBefore<num extends string, def = "0"> = num extends `${infer before}${K}` ? (before extends "" ? def : before) : (def);
type If_StrLenGt2<T extends string> = 0 extends Len<T> ? false : 1 extends Len<T> ? false : true;
export type PlusPositionStrNum<num1 extends string, num2 extends string, result extends string = "", last1 extends boolean = true, last2 extends boolean = true> = If_BothFalse<last1, last2> extends true ? (num1 extends "1" ? (`1${result}`) : (num2 extends "1" ? `1${result}` : result)) : (PlusPositionStrNum<PlusOverBoolMap[PopLast<num1> & K][PopLast<num2> & K] extends true ? IncreaserStrNum<PopBefore<num1>> : PopBefore<num1>, PopBefore<num2>, `${PlusMantissaMap[PopLast<num1> & K][PopLast<num2> & K]}${result}`, If_StrLenGt2<num1>, If_StrLenGt2<num2>>);
export type _DelLeftZero<num extends string> = num extends `0${infer after}` ? after extends "" ? "0" : _DelLeftZero<after> : num;
export type SubPositionStrNum<num1 extends string, num2 extends string, result extends string = "", last1 extends boolean = true, last2 extends boolean = true> = If_BothFalse<last1, last2> extends true ? (_DelLeftZero<result>) : (SubPositionStrNum<SubShrinkBoolMap[PopLast<num1> & K][PopLast<num2> & K] extends true ? DecreaserStrNum<PopBefore<num1>> : PopBefore<num1>, PopBefore<num2>, `${SubMantissaMap[PopLast<num1> & K][PopLast<num2> & K]}${result}`, If_StrLenGt2<num1>, If_StrLenGt2<num2>>);
type MulSingleStrNum<num extends string, single_num extends K, result extends string = "", over_num extends string = "0"> = If_Never<PopLast<num, never>> extends true ? (over_num extends "0" ? result : `${over_num}${result}`) : (PlusPositionStrNum<MulMap[PopLast<num> & K][single_num], over_num> extends infer curr_num extends string ? (MulSingleStrNum<PopBefore<num, never>, single_num, `${PopLast<curr_num>}${result}`, PopBefore<curr_num>>) : (never));
export type MulPositionStrNum<num1 extends string, num2 extends string, result extends string = "0", mantissa_zero extends string = ""> = If_Never<PopLast<num2, never>> extends true ? (_DelLeftZero<result>) : (MulPositionStrNum<num1, PopBefore<num2, never>, PlusPositionStrNum<result, `${MulSingleStrNum<num1, PopLast<num2>>}${mantissa_zero}`>, `${mantissa_zero}0`>);
type _FindMaxDivSingleStrNum<num1 extends string, num2 extends string, member extends string = "0123456789", before extends string = "", mul_ret extends string = ""> = If_EmptyStr<member> extends true ? ([
    before,
    SubPositionStrNum<num1, mul_ret>
]) : (member extends `${infer curr}${infer rest}` ? (MulPositionStrNum<num2, curr> extends infer ret extends string ? (ret extends num1 ? ([
    curr,
    SubPositionStrNum<num1, ret>
]) : (If_PositiveStrLt<ret, num1> extends true ? (_FindMaxDivSingleStrNum<num1, num2, rest, curr, ret>) : ([
    before,
    SubPositionStrNum<num1, mul_ret>
]))) : (never)) : (never));
type _SplitJoin<num extends string, value extends string> = num extends `${infer curr}${infer rest}` ? ([
    curr: curr,
    rest: rest,
    div_num: _DelLeftZero<`${value}${curr}`>
]) : ([
]);
export type DivPositionStrNum<num1 extends string, num2 extends string, result extends string = "", div_num extends string = ""> = _SplitJoin<num1, div_num> extends [infer curr extends string, infer rest extends string, infer curr_div_num extends string] ? (If_PositiveStrGte<curr_div_num, num2> extends true ? (_FindMaxDivSingleStrNum<curr_div_num, num2> extends [infer div_int extends string, infer rem_num extends string] ? (DivPositionStrNum<rest, num2, `${result}${div_int}`, rem_num extends "0" ? "" : rem_num>) : (never)) : (DivPositionStrNum<rest, num2, `${result}0`, `${div_num}${curr}`>)) : (_DelLeftZero<result>);
export type RemPositionStrNum<num1 extends string, num2 extends string, result extends string = ""> = _SplitJoin<num1, result> extends [infer curr extends string, infer rest extends string, infer curr_div_num extends string] ? (If_PositiveStrGte<curr_div_num, num2> extends true ? (_FindMaxDivSingleStrNum<curr_div_num, num2> extends [string, infer rem_num extends string] ? (RemPositionStrNum<rest, num2, rem_num extends "0" ? "" : rem_num>) : (never)) : (RemPositionStrNum<rest, num2, `${result}${curr}`>)) : (result extends "" ? "0" : result);
export type DivRemPositiveStrNum<num1 extends string, num2 extends string, int_num extends string = "", rem_num extends string = ""> = _SplitJoin<num1, rem_num> extends [infer curr extends string, infer rest extends string, infer curr_rem_num extends string] ? (If_PositiveStrGte<curr_rem_num, num2> extends true ? (_FindMaxDivSingleStrNum<curr_rem_num, num2> extends [infer div_int extends string, infer rem_num extends string] ? (DivRemPositiveStrNum<rest, num2, `${int_num}${div_int}`, rem_num extends "0" ? "" : rem_num>) : (never)) : (DivRemPositiveStrNum<rest, num2, `${int_num}0`, `${rem_num}${curr}`>)) : ([
    int_num: _DelLeftZero<int_num>,
    rem_num: rem_num
]);
export type Plus<n1 extends string | number | bigint, n2 extends string | number | bigint, TargetType extends string | number | bigint = TypeOf<n1>> = PlusPositionStrNum<Str<n1>, Str<n2>> extends `${infer R extends TargetType}` ? R : never;
export type Sub<n1 extends string | number | bigint, n2 extends string | number | bigint, TargetType extends string | number | bigint = TypeOf<n1>> = If_Gt<n2, n1> extends true ? (never) : (SubPositionStrNum<Str<n1>, Str<n2>> extends `${infer R extends TargetType}` ? R : never);
export type Mul<n1 extends string | number | bigint, n2 extends string | number | bigint, TargetType extends string | number | bigint = TypeOf<n1>> = MulPositionStrNum<Str<n1>, Str<n2>> extends `${infer R extends TargetType}` ? R : never;
export type Div<n1 extends string | number | bigint, n2 extends string | number | bigint, TargetType extends string | number | bigint = TypeOf<n1>> = DivPositionStrNum<Str<n1>, Str<n2>> extends `${infer R extends TargetType}` ? R : never;
export type Rem<n1 extends string | number | bigint, n2 extends string | number | bigint, TargetType extends string | number | bigint = TypeOf<n1>> = RemPositionStrNum<Str<n1>, Str<n2>> extends `${infer R extends TargetType}` ? R : never;
export type DivRem<n1 extends string | number | bigint, n2 extends string | number | bigint, TargetType extends string | number | bigint = TypeOf<n1>> = DivRemPositiveStrNum<Str<n1>, Str<n2>> extends [infer I extends string | number | bigint, infer R extends string | number | bigint] ? [int_num: Type<I, TargetType>, rem_num: Type<R, TargetType>] : never;
export type MulSum<ns extends Array<number | string>, result extends number = 1> = ns extends [infer first extends string | number, ...infer rest extends (string | number)[]] ? MulSum<rest, Mul<result, first>> : result;
export {};
